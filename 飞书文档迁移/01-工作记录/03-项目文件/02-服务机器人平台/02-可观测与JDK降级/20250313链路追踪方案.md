---
created: '2025-02-17 10:58:44'
feishu_url: https://wk5tnvpfe7.feishu.cn/docx/LD7odZ9Xkoss4BxXOdScMs65ngg
modified: '2025-03-13 14:45:23'
source: feishu
title: 20250313链路追踪方案
---

20250313链路追踪方案


版本号

更新时间

更新内容

更新人

0.0.1

2025年2月17日

根据服务机器人1.1版本需求、1.0版本调研结果，编写文档

陈亚男

0.0.2

2025年2月18日


补充可观测agent方式接入的选型原因
补充前端增加sw8的示例代码
结合事业部的日志规范，给出改造要求、日志的格式，增加样例说明
针对日志样例，增加每个字段对应的说明
增加日志接入的上下游应用的要求与链路关系

陈亚男

0.0.3

2025年3月11日

增加python链路接入和日志接入

陈亚男
背景
在微服务架构下，服务机器人1.0的系统涉及多个模块的HTTP/WebSocket通信，由于需快速定位跨服务调用问题。在1.0版本对接了开源组件：SkyWalking，初步实现了链路追踪、拓扑分析的能力，满足了前期的链路追踪的需求。
服务机器人1.1版本对链路追踪、日志分析的需求要求更加复杂，原有开源组件已经不满足需求，计划对接公司内部：可观测平台系统。其能够：
提供覆盖全栈的监控能力，覆盖服务器，容器，数据库，中间件，网络与安全设备、算力服务器/芯片等关键指标的实时可视化监控，提高线上问题自动发现效率
通过收集和分析应用的日志、指标和追踪数据，可观测平台可以快速定位问题源头，提高运维排障效率
性能优化与瓶颈分析，深度分析系统性能数据，识别并解决性能瓶颈，持续提升系统响应速度和处理能力
技术选型
目前可观测平台提供了多种接入方式，针对当前的版本需求，计划采用skywalking agent接入可观测平台
skywalking agent，低侵入性对于现有系统的影响小。后端服务仅需要调整代码依赖项、通过 Java Agent 机制实现监控，只需在启动时添加参数即可，对业务代码无侵入。前端代码调整统一调整增加sw8请求头即可
skywalking agent，支持多种框架。包括Spring Boot、Mysql、Dubbo等
可观测平台基于skywalking，与 SkyWalking 平台深度集成，支持java\python语言、http\ws协议：数据可直接上报至 SkyWalking OAP 服务，结合 UI 实现可视化分析
前期需求
综合1.0版本实现的情况，结合1.0版本前期的调研情况、目前各个局点的运行实际业务场景，本次的1.1版本需求主要为以下2点
请求链路跟踪
通过监控平台进行链路追踪，用traceid跟踪一次请求从开始到结束，分别哪台服务器上哪个服务
服务日志查看
能够通过可观测平台进行日志检索，无需通过服务器进行日志检索、查看
实现方案
基于第二节的两类需求，结合当前的可观测平台系统进行了可行性验证，同时梳理了对接方案和场景

请求链路跟踪
整体链路逻辑
当前系统请求链路整体分3类
单次链路仅有http请求
单次链路仅有ws请求
单次链路存在http与ws协议交叉使用

功能验证结果（Java）
image.png

image.png

单次链路仅有http请求=验证通过
前端A增加http请求头增加sw8协议
请求头使用sw8协议，sw8是一个在header中传递的数据项，它的key为【sw8】，value为8个字段组成，由【-】分割的一个字符串。（只需调用方前端修改）https://blog.csdn.net/wudonghe1996/article/details/140932394
sw8值详解（由8个部分组成）
1. 采样(Sample)：0 / 1，0表示上下文存在，但是可以忽略，1表示此追踪需要采样并发送到后端。
2. 追踪标识(Trace Id)：字符串（BASE64 编码），这里是主要自定义的部分。（可用雪花算法生成）
3. 父追踪段 ID(Parent Segment Id)：全局唯一的字符串（BASE64 编码），可以使用traceId。
4. 父 Span 标识：int类型，从0开始，此 Span ID 指向了父追踪段中的 Span，我们这里模拟的是头服务，所以设置为0即可。
5. 父服务：字符串(BASE64 编码)，这里可以设置成你要模拟的头服务的名字。
6. 父服务实例标识：字符串(BASE64 编码)，这里可以设置成同上。
7. 父服务的端点：字符串(BASE64 编码)：父追踪段中第一个入口span的操作名。
8. 本请求的目标地址：字符串(BASE64 编码)，可以简单设置为本机IP地址。

示例：sw8:1-MTEtMzQ4OTUyODAxMTY0NzA5MDcwNA==-MTEtMzQ4OTUyODAxMTY0NzA5MDcwNA==-0-cGFyZW50-cGFyZW50-aGVsbG8=-MTI3LjAuMC4x
原文：1-11-3489528011647090704-11-3489528011647090704-0-parent-parent-hello-127.0.0.1
服务A\B\C后端服务增加启动配置
对应服务器上需要首先安装java的agent插件
1. docker类应用，docker的配置文件，增加agent，并添加环境变量

JAVA_TOOL_OPTIONS="-javaagent:/app/skywalking-agent/skywalking-agent.jar"  # 需要使用可观测定制化agent
SW_AGENT_COLLECTOR_BACKEND_SERVICES="172.29.231.169:11800"   # 可观测的调用链系统
SW_AGENT_NAME="agent-docker"   # 可观测的上的接入的应用名称
SW_AGENT_NAMESPACE="tok_a77d0427cb284012a8b783520e6bab84"   # 可观测的上的接入应用id

2. jar包类应用，直接在启动命令上添加
-javaagent:/usr/local/stplugins/st_java_sniffer/default/bin/skywalking-agent/skywalking-agent.jar=agent.service_name=traceId-demo1,agent.namespace=tok_a77d0427cb284012a8b783520e6bab84,collector.backend_service=172.29.231.169:11800

3. tongweb类应用 
在tongweb控制页面每个实例-->基础配置-->启动参数添加
-javaagent:/usr/local/stplugins/st_java_sniffer/default/bin/skywalking-agent/skywalking-agent.jar=agent.service_name=traceId-demo1,agent.namespace=tok_a77d0427cb284012a8b783520e6bab84,collector.backend_service=172.29.231.169:11800

单次链路仅有ws请求
前端增加websocket请求体增加sw8协议
请求头使用sw8协议，sw8是一个在header中传递的数据项，它的key为【sw8】，value为8个字段组成，由【-】分割的一个字符串。（只需调用方前端修改）https://blog.csdn.net/wudonghe1996/article/details/140932394
sw8值详解（由8个部分组成）
1. 采样(Sample)：0 / 1，0表示上下文存在，但是可以忽略，1表示此追踪需要采样并发送到后端。
2. 追踪标识(Trace Id)：字符串（BASE64 编码），这里是主要自定义的部分。（可用雪花算法生成）
3. 父追踪段 ID(Parent Segment Id)：全局唯一的字符串（BASE64 编码），可以使用traceId。
4. 父 Span 标识：int类型，从0开始，此 Span ID 指向了父追踪段中的 Span，我们这里模拟的是头服务，所以设置为0即可。
5. 父服务：字符串(BASE64 编码)，这里可以设置成你要模拟的头服务的名字。 、可以根据服务类型进行修改、
6. 父服务实例标识：字符串(BASE64 编码)，这里可以设置成同上。
7. 父服务的端点：字符串(BASE64 编码)：父追踪段中第一个入口span的操作名。
8. 本请求的目标地址：字符串(BASE64 编码)，可以简单设置为本机IP地址。

示例：sw8:1-MTEtMzQ4OTUyODAxMTY0NzA5MDcwNA==-MTEtMzQ4OTUyODAxMTY0NzA5MDcwNA==-0-cGFyZW50-cGFyZW50-aGVsbG8=-MTI3LjAuMC4x
原文：1-113489528011647090704-113489528011647090704-0-parent-parent-hello-127.0.0.1
服务A\B\C后端服务增加启动配置
对应服务器上需要首先安装java的agent插件
1. docker类应用，docker的配置文件，增加agent，并添加环境变量

JAVA_TOOL_OPTIONS="-javaagent:/app/skywalking-agent/skywalking-agent.jar"  # 需要使用可观测定制化agent
SW_AGENT_COLLECTOR_BACKEND_SERVICES="172.29.231.169:11800"   # 可观测的调用链系统
SW_AGENT_NAME="agent-docker"   # 可观测的上的接入的应用名称
SW_AGENT_NAMESPACE="tok_a77d0427cb284012a8b783520e6bab84"   # 可观测的上的接入应用id

2. jar包类应用，直接在启动命令上添加
-javaagent:/usr/local/stplugins/st_java_sniffer/default/bin/skywalking-agent/skywalking-agent.jar=agent.service_name=traceId-demo1,agent.namespace=tok_a77d0427cb284012a8b783520e6bab84,collector.backend_service=172.29.231.169:11800

3. tongweb类应用 
在tongweb控制页面每个实例-->基础配置-->启动参数添加
-javaagent:/usr/local/stplugins/st_java_sniffer/default/bin/skywalking-agent/skywalking-agent.jar=agent.service_name=traceId-demo1,agent.namespace=tok_a77d0427cb284012a8b783520e6bab84,collector.backend_service=172.29.231.169:11800
服务A\B\C后端服务需要在对应的classpath默认配置资源路经中，增加：skywalking.properties
# 需要进行链路追踪的websocket的netty的服务端实现类。多个使用,号分割
netty.server.class=com.iflytek.srp.knowledge.apply.web.socket.WebSocketNettyServerHandler
# 需要进行链路追踪的websocket的netty的客户端实现类
netty.client.class=com.iflytek.srp.knowledge.apply.web.socket.WebSocketNettyClientHandler
单次链路存在http与ws协议交叉使用：与单次链路仅有ws请求相同
示例代码
请求链路追踪要求链路起点的请求头中增加sw8属性，以服务机器人前端为例，以下是示例代码
链路起点为前端HTTP（区分集成场景）
// http.js中headers增加sw8字段
// http://172.31.241.12:8081/robot/design/bot/pageList 为例
function (config) {
  // 定义 BASE64 编码函数（处理 UTF-8 字符）
  const base64Encode = (str) => btoa(unescape(encodeURIComponent(str)));
  // 生成请求唯一标识和基础逻辑
  config._reqId = generateUID();
  // 设置语言头
  config.headers['Language'] = localStorage.getItem('language') || 'zh_CN';
  。。。。。。
  // 新增 SkyWalking 链路追踪头 sw8
  config.headers['sw8'] = [
    '1',  // 采样标志（1=采样）
    base64Encode(config._reqId),  // Trace ID uuid
    base64Encode(config._reqId),  // Parent Segment ID（同 Trace ID）
    '0',  // Parent Span ID（头服务固定为 0）
    base64Encode('srp-robot'),  // Parent Service，可以根据服务类型进行修改 /knowledge
    base64Encode('srp-robot-design'),  // Parent Service Instance，可以根据服务接口类型进行修改 /manager/searchConf
    base64Encode('bot-pageList'),  // Parent Endpoint（入口 Span 名称）,接口名称 /indexConf
    base64Encode('127.0.0.1')  // （本机 IP）
  ].join('-');
}
链路起点为前端WebSocket
// 需要在websocket的sendMessage中的param中，增加 traceBase64 字段
      this.ws.onopen = () => {
        const params = {
          sessionId: this.callId,
          chatType: this.chatType,
          docqaCategoryIdList: docqaCategoryIdList,
          question: searchedTxt,
          tenantId: this.userInfo.currentTenantId,
          userName: this.userInfo.loginName
          traceBase64: "sw8String"
        };
        this.ws.send(JSON.stringify(params));
       }
功能验证结果（Python）
python目前使用的是demo程序进行接入测试，使用python编写一个http/ws服务端，接受服务端请求
增加python依赖
pip install
pip install flask-socketio
pip install apache-skywalking
测试python代码以及可观测配置
app.py
from flask import Flask, render_template, request
from flask_socketio import SocketIO, emit  # 新增导入
from skywalking import agent, config
from skywalking.loggings import logger

config.init(
    agent_collector_backend_services="172.29.234.103:11800",
    agent_protocol="grpc",
    agent_name="srp-python-test",
    agent_namespace="tok_20122c7a898c497e88285b926869af3c",
    agent_instance_name="srp-python-test",
    agent_experimental_fork_support=True,
    agent_log_reporter_formatted=True,
    agent_log_reporter_level="INFO",
    agent_log_reporter_layout="%(tid)s %(asctime)s [%(threadName)s] %(levelname)s %(name)s - %(message)s",
    agent_logging_level="DEBUG",
    agent_log_reporter_active=True,
    agent_meter_reporter_active=True,
    agent_profile_active=True,
)
agent.start()

app = Flask(__name__)
socketio = SocketIO(app)  # 新增SocketIO初始化

@app.route("/", methods=["GET", "POST"])
def index():
    result = None
    if request.method == "POST":
        input_text = request.form.get("input_text")
        # 记录日志
        logger.info(f"接收到 POST 请求，输入文本: {input_text}")
        result = f"[已处理] {input_text}"
        # 记录处理结果日志
        logger.info(f"处理结果: {result}")
    return render_template("index.html", result=result)

@socketio.on('client_message')  # 新增WebSocket消息处理器
def handle_message(message):
    logger.info(f"接收到WebSocket请求，输入文本: {message['data']}")
    processed = f"[WS处理] {message['data']}"
    emit('server_response', {'data': processed})
    logger.info(f"WebSocket处理结果: {processed}")

if __name__ == "__main__":
    # 修改启动方式以支持WebSocket
    socketio.run(app, host="0.0.0.0", port=8080, debug=False)
链路接入情况
image.png

服务日志查看
可观测平台提供了各类服务日志接入的功能，接入后可在可观测的页面上进行服务日志查看与检索，无需通过登录服务器进行日志检索查看。整体有以下4类（日志接入操作文档）
JSON格式日志（日志接入操作文档）
正则匹配接入
Nginx日志接入
SDK接入（以下以此为例）
Mariadb慢查询接入（与正则匹配类似）
image.png

整体链路逻辑
综合可观测平台接入要求以及事业部日志接入规范，保证可以进行端到端的日志追踪。
演示日志接入的流程，以文字客服机器人的一次机器人接入会议为例：

参考以上交互流程（1.0-5.5），每个节点都需要打印出参入参的日志，即有以下三种类型
链路请求入口，即以上流程的（1.0、2.0、3.0），HTTP请求头中需要增加sw8，ws链接参数中需要增加 traceBase64字段其值与sw8生成规则相同，参考：请求链路跟踪-示例代码
每个服务节点的对外接口即以上流程的（4.0、4.4、5.0、5.5）、调用外部接口即以上流程的（4.1、4.2、5.2、5.4）的入参、出参
服务节点中处理的关键日志信息，即以上流程的（4,3、5.1、5.3）
不同类型日志打印的内容要包括以下要素
接口出参、入参形式
# 日志级别默认为INFO，以JAVA举例子，建议封装httpclient，增加对应日志切面实现
# 代码中应该包含:执行类名方法名、执行耗时、方法入参、方法出参,日志格式如下
log.info("request-0 method : {}", className + methodName );
log.info("request-1 params : {}", args);
log.info("request-2 time : {} ms", time);
log.info("request-3 return : {}", result);

# 参考切面伪代码
@log
public Object around(ProceedingJoinPoint point) throws Throwable {
    long startTime = System.currentTimeMillis();
    // 执行方法
    Object result = point.proceed();
    // 执行时长(毫秒)
    long endTime = System.currentTimeMillis();
    long time = endTime - startTime;
    // 打印日志
    log.(point, time, result);
    return result;
}
关键日志形式
# 日志级别默认为INFO，以JAVA举例子，直接使用log框架打印
# 代码中应该包含:需要输出的信息，例如，关键内部方法入参（info）、SQL执行结果(deb)等（日志规范）
log.info("【推荐问】当前回复为最后一帧,准备清理与引擎连接的推荐问客户端,通道key为:{}", key);

# 其余的信息，集成的可观测的框架会自动填写（参考服务日志查看-日志示例）
接入规范
Java应用功能（SDK接入）
image.png

安装java的agent插件
对应服务器上需要首先安装可观测平台的agent包
调整skywalking依赖
<dependency>
    <groupId>com.iflytek.itsc.apm</groupId>
    <artifactId>apm-toolkit-logback-1.x</artifactId>
</dependency>
调整logback配置文件
<?xml version="1.0" encoding="UTF-8"?>
<!-- 配置文件每隔1分钟，就检查更新 -->
<configuration scan="true" scanPeriod="60 seconds" debug="false">
    <!-- 定义参数常量，便于后面直接用${name}来获取value值 -->
    <property name="log.pattern" value="%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] [%-5level] %logger{50} - %msg%n"/>
    <property name="log.filePath" value="logs"/>
    <property name="serviceName" value="maintenance-manager"/>
    <property name="log.maxHistory" value="7"/>

    <!-- ch.qos.logback.core.ConsoleAppender 控制台输出 -->
    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <!--        <encoder>-->
        <!--            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} %-5level [%thread] %logger{50} - %msg%n</pattern>-->
        <!--        </encoder>-->
        <encoder class="ch.qos.logback.core.encoder.LayoutWrappingEncoder">
            <layout
                    class="com.iflytek.itsc.apm.logback.layout.GeneralJsonStringLayout">
            </layout>
        </encoder>
    </appender>

    <appender name="SERVICELOGFILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>${log.filePath}/service.log</file>
        <!-- 设置基于时间(每天)的滚动策略，也就是将日志内容按照日期来写入到相应的文件中-->
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <!-- 当天之前的每天生成的日志文件的路径 -->
            <fileNamePattern>${log.filePath}/service-%d{yyyy-MM-dd}.log.gz
            </fileNamePattern>
            <!-- 最大历史保存文件的数量，只保存最近30天的日志文件，超出的会被删除-->
            <maxHistory>${log.maxHistory}</maxHistory>
        </rollingPolicy>
        <encoder class="ch.qos.logback.core.encoder.LayoutWrappingEncoder">
            <layout
                    class="com.iflytek.itsc.apm.logback.layout.GeneralJsonStringLayout">
            </layout>
        </encoder>
    </appender>

    <appender name="REQUESTLOGFILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>${log.filePath}/request.log</file>
        <!-- 设置基于时间(每天)的滚动策略，也就是将日志内容按照日期来写入到相应的文件中-->
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <!-- 当天之前的每天生成的日志文件的路径 -->
            <fileNamePattern>${log.filePath}/request-%d{yyyy-MM-dd}.log.gz
            </fileNamePattern>
            <!-- 最大历史保存文件的数量，只保存最近30天的日志文件，超出的会被删除-->
            <maxHistory>${log.maxHistory}</maxHistory>
        </rollingPolicy>
        <encoder class="ch.qos.logback.core.encoder.LayoutWrappingEncoder">
            <layout
                    class="com.iflytek.itsc.apm.logback.layout.GeneralJsonStringLayout">
            </layout>
        </encoder>
    </appender>
    <appender name="INTEGRATIONLOGFILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>${log.filePath}/integration.log</file>
        <!-- 设置基于时间(每天)的滚动策略，也就是将日志内容按照日期来写入到相应的文件中-->
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <!-- 当天之前的每天生成的日志文件的路径 -->
            <fileNamePattern>${log.filePath}/integration-%d{yyyy-MM-dd}.log.gz
            </fileNamePattern>
            <!-- 最大历史保存文件的数量，只保存最近30天的日志文件，超出的会被删除-->
            <maxHistory>${log.maxHistory}</maxHistory>
        </rollingPolicy>
        <encoder class="ch.qos.logback.core.encoder.LayoutWrappingEncoder">
            <layout
                    class="com.iflytek.itsc.apm.logback.layout.GeneralJsonStringLayout">
            </layout>
        </encoder>
    </appender>

    <appender name="DEFAULTLOGFILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>${log.filePath}/default.log</file>
        <!-- 设置基于时间(每天)的滚动策略，也就是将日志内容按照日期来写入到相应的文件中-->
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <!-- 当天之前的每天生成的日志文件的路径 -->
            <fileNamePattern>${log.filePath}/default-%d{yyyy-MM-dd}.log.gz
            </fileNamePattern>
            <!-- 最大历史保存文件的数量，只保存最近30天的日志文件，超出的会被删除-->
            <maxHistory>${log.maxHistory}</maxHistory>
        </rollingPolicy>
        <encoder class="ch.qos.logback.core.encoder.LayoutWrappingEncoder">
            <layout
                    class="com.iflytek.itsc.apm.logback.layout.GeneralJsonStringLayout">
            </layout>
        </encoder>
    </appender>

    <appender name="ERRORLOGFILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>${log.filePath}/error.log</file>
        <!-- 设置基于时间(每天)的滚动策略，也就是将日志内容按照日期来写入到相应的文件中-->
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <!-- 当天之前的每天生成的日志文件的路径 -->
            <fileNamePattern>${log.filePath}/error-%d{yyyy-MM-dd}.log.gz
            </fileNamePattern>
            <!-- 最大历史保存文件的数量，只保存最近30天的日志文件，超出的会被删除-->
            <maxHistory>${log.maxHistory}</maxHistory>
        </rollingPolicy>
        <encoder class="ch.qos.logback.core.encoder.LayoutWrappingEncoder">
            <layout
                    class="com.iflytek.itsc.apm.logback.layout.GeneralJsonStringLayout">
            </layout>
        </encoder>
        <!-- 过滤掉非error级别的信息 -->
        <filter class="ch.qos.logback.classic.filter.LevelFilter">
            <level>error</level>
            <onMatch>ACCEPT</onMatch>
            <onMismatch>DENY</onMismatch>
        </filter>
    </appender>

    <appender name="ASYNCSERVICELOGFILE" class="ch.qos.logback.classic.AsyncAppender" includeCallerData="true">
        <appender-ref ref="SERVICELOGFILE"/>
    </appender>

    <appender name="ASYNCERRORLOGFILE" class="ch.qos.logback.classic.AsyncAppender" includeCallerData="true">
        <appender-ref ref="ERRORLOGFILE"/>
    </appender>

    <appender name="ASYNCREQUESTLOGFILE" class="ch.qos.logback.classic.AsyncAppender" includeCallerData="true">
        <appender-ref ref="REQUESTLOGFILE"/>
    </appender>

    <appender name="ASYNCINTEGRATIONLOGFILE" class="ch.qos.logback.classic.AsyncAppender" includeCallerData="true">
        <appender-ref ref="INTEGRATIONLOGFILE"/>
    </appender>

    <appender name="ASYNCDEFAULTLOGFILE" class="ch.qos.logback.classic.AsyncAppender" includeCallerData="true">
        <appender-ref ref="DEFAULTLOGFILE"/>
    </appender>


    <logger name="serviceLogger" additivity="false">
        <appender-ref ref="ASYNCSERVICELOGFILE"/>
        <appender-ref ref="ASYNCERRORLOGFILE"/>
    </logger>

    <logger name="requestLogger" additivity="false">
        <appender-ref ref="ASYNCREQUESTLOGFILE"/>
        <appender-ref ref="ASYNCERRORLOGFILE"/>
    </logger>

    <logger name="integrationLogger" additivity="false">
        <appender-ref ref="ASYNCINTEGRATIONLOGFILE"/>
        <appender-ref ref="ASYNCERRORLOGFILE"/>
    </logger>

    <root level="info">
        <appender-ref ref="CONSOLE"/>
        <appender-ref ref="ASYNCDEFAULTLOGFILE"/>
    </root>
</configuration>
调整compose.yml
services:
   srp-maintenance-manager:
    image: "artifacts.iflytek.com/znfw-docker-repo/fwjqrcppt/maintenancemanager:v1.1_${VERSION}"
    network_mode: "host"
    container_name: "srp-maintenance-manager"
    environment:
      JAVA_TOOL_OPTIONS: "-javaagent:/skywalking/agent/skywalking-agent.jar"
      SW_AGENT_NAME: srp-maintenance-manager
      SW_AGENT_COLLECTOR_BACKEND_SERVICES: 172.29.234.103:11800
      SW_AGENT_NAMESPACE: tok_20122c7a898c497e88285b926869af3c
      #NODE_NAME: "NodeNamePlaceholder"
      #DUBBO_IP_TO_REGISTRY: "172.31.241.12"
      SW_AGENT_SAMPLE: 3000
    volumes:
      - /data/docker-data/maintenance-manager/logs:/usr/local/maintenance-manager/logs
      - /data/docker-data/maintenance-manager/config:/usr/local/maintenance-manager/config
      - /data/docker-data/maintenance-manager/start.sh:/usr/local/maintenance-manager/start.sh
      #- /data/docker-data/maintenance-manager/agent_logs:/skywalking/agent/logs
      - /data/skywalking-agent:/skywalking/agent
volumes:
  skywalking-agent:
配置可观测平台
配置agent
image.png

增加日志接入点
image.png

Nginx日志接入
docker启动的需要增加log目录映射
nginx安装可观测平台要求，调整log format
log_format main '{"http_referer":"$http_referer","remote_addr":"$remote_addr","remote_user":"$remote_user","request_uri":"$request_uri","request_length":"$request_length","request_time":"$request_time","request_method":"$request_method","upstream_addr":"$upstream_addr","upstream_response_time":"$upstream_response_time","http_user_agent":"$http_user_agent","http_x_forwarded_for":"$http_x_forwarded_for","status":"$status","time_local":"$time_iso8601","body_bytes_sent":"$body_bytes_sent","bytes_sent":"$bytes_sent","connection":"$connection","host":"$host","uri":"$uri"}';
配置可观测平台
配置agent
image.png

增加日志接入点
image.png


Python日志接入
参考测试python代码以及可观测配置中的的可观测配置，调整启动脚本如下

#!/bin/bash
nohup python3 app.py >> app.log 2>&1 &
echo "应用已启动，日志输出到 app.log"
接入情况（使用正则接入）

#参考日志
2025-03-11 14:10:10,612 skywalking [pid:2125979] [Thread-9] [DEBUG] Reporting Log

#参考正则
^(?<timestamp>\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2},\d{3})\s+(?<service>\S+)\s+\[pid:(?<pid>\d+)\]\s+\[(?<thread>.+?)\]\s+\[(?<level>\w+)\]\s+(?<message>.+)
image.png

日志示例
Java日志示例
# java应用接入一般要求接入logback\log4j2\log4j日志框架，然后按照上述要求调整相关配置xml
# 示例java代码中，使用log记录应用日志

log.info("-----updateKnowledgeSearchRecord释放锁----"); 

# 可观测平台会根据xml的配置，格式化输出日志如下,除log中的message，其余会根据配置自动生成：
{
  # 自动生成，根据异常情况进行生成
  "exception": "", 
  # 由前端生成增加到请求头中
  "trace_id": "deb2df4e504c45a7b5969dca79e0ffe9.283.17399349200005651", 
  # 日志级别，在xml中配置
  "level": "INFO", 
  # 自动获取日志打印时的方法全路径
  "endpoint_name":  "SpringScheduled/com.iflytek.srp.maintenance.manager.schedule.MaintenanceTask.updateKnowledgeSearchRecord", 
  # 自动获取服务节点ip 
  "ip": "172.31.241.12", 
  # 自动获取日志打印时的类 
  "logger": "com.iflytek.srp.maintenance.manager.schedule.MaintenanceTask", 
  # 手动，程序中需要输出的日志信息
  "message": "-----updateKnowledgeSearchRecord释放锁----", 
  # 自动获取线程名 
  "threadName": "scheduling-1", 
  # 自动获取节点名称 
  "application": "srp-maintenance-manager|tok_20122c7a898c497e88285b926869af3c|", 
  # 自动获取日志打印时的方法名
  "method_name": "updateKnowledgeSearchRecord", 
  # 自动获取日志打印时的时间 
  "log_date": "2025-02-19 11:15:20.002", 
  # 自动生成服务示例名称
  "service_instance_name": "97c593a89393444abb62bdcd88ec46e3@172.17.0.1" 
}
Json日志示例
# json格式的日志，要求单个日志为一行
# 格式化如下：
{
    "traceId":"",   
    "level":"INFO", 
    "dateTime":1700706936805920072,
    "ip":"172.30.12.119",
    "application":"LokiTest",
    "methodName":"logTest",
    "logger":"com.my.loki.test.LogTest",
    "message":"The turtle can grow up to 303 years old, and this year it is 147 years old.",
    "exception":"",
    "source":"71db762c-74e2-4e23-bb7b-04c0e66db6fd",
    "threadName":"main"
}
# 文件日志输出应该为1行：
{"traceId":"","level":"INFO","dateTime":1700706936805920072,"ip":"172.30.12.119","application":"LokiTest","methodName":"logTest","logger":"com.my.loki.test.LogTest","message":"The turtle can grow up to 303 years old, and this year it is 147 years old.","exception":"","source":"71db762c-74e2-4e23-bb7b-04c0e66db6fd","threadName":"main"}
工作量评估以及资源需求
以下目前仅评估服务机器人的改造工作量

后续代办
对应服务器需要部署可观测平台的agent包(轻量化、ws)
websocket的链路追踪目前处于联调测试阶段
需要手动添加一个定制jar包到可观测平台的Agent的插件目录
目前单个服务不支持多个client和server的链路追踪（预计3月3号开始研发）
python等非java应用的链接追踪目前完成初步验证

